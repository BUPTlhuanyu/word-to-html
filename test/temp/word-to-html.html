
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no,viewport-fit=cover">
            <title></title>
            <script>
                (function (doc, win) {
                    let docEl = doc.documentElement,
                        resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
                        recalc = function () {
                            let clientWidth = docEl.clientWidth;
                            if (!clientWidth) return;
                            if (clientWidth >= 640) {
                                docEl.style.fontSize = '100px';
                            } else {
                                docEl.style.fontSize = 100 * (clientWidth / 750) + 'px';
                                let div = document.createElement('div');
                                div.style.width = '1.4rem';
                                div.style.height = '0';
                                document.body.appendChild(div);
                                let ideal = 140 * clientWidth / 750;
                                let rmd = (div.clientWidth / ideal);
                                if (rmd > 1.2 || rmd < 0.8) {
                                    docEl.style.fontSize = 100 * (clientWidth / 750) / rmd + 'px';
                                }
                                document.body.removeChild(div);
                            }
                        };
                        if (!doc.addEventListener) return;
                        win.addEventListener(resizeEvt, recalc, false);
                        doc.addEventListener('DOMContentLoaded', recalc, false);
                    }
                )(document, window);
            </script>
            <style>
                body,
                html,
                table {
                    padding: 0;
                    margin: 0;
                }
                p {
                    margin: 0.14rem 0;
                    list-style-type: none;
                    font-family: PingFang-SC-Medium;
                    font-size: 0.28rem;
                    color: #848484;
                    letter-spacing: 0;
                    text-align: justify;
                    line-height: 0.48rem;
                    padding: 0 0.3rem;
                }
                td {
                    border: 1px solid #000;
                    text-align: left;
                    vertical-align: top;
                    font-family: PingFang-SC-Medium;
                    font-size: 0.28rem;
                    color: #848484;
                }
                .container>table {
                    width: 6.9rem;
                }
                table {
                    border-collapse: collapse;
                }
                .container {
                    padding: 0.3rem
                }
            </style>
	        </head>
	    <body>
            <noscript>You need to enable JavaScript to run this app.</noscript>
            <div class="container"><p><span style="font-family:宋体;font-size:0.3rem;">动机：</span></p><p><span style="">保险行业有各种各样的条款</span><span style="">，</span><span style="">如何展示这些</span><span style="">文字内容巨多但又非常重要的</span><span style="">条款是</span><span style="">我们面临的一个关键问题，目前有两个方案：第一个</span><span style="">以pdf的形式展示</span><span style="">，这种方案是借用一些pdf插件来展示条款，由于目前项目中主要的场景是用户通过移动端来查看条款，因此是存在一些问题的，比如直接展示pdf文档无法随着移动端设备的变化自适应的进行排版以达到清晰的呈现。</span><span style="">第二个以</span><span style="">html</span><span style="">静态文件</span><span style="">的形式</span><span style="">来展示这些条款</span><span style="">，可想而知，在浏览器上渲染html文件必定优于在浏览器上展示pdf文件，因此第二种方案具有速度快、能自适应不同设备、体验好的优点。</span></p><p><span style="font-family:宋体;font-size:0.3rem;">问题：</span></p><p><span style="">给的文件是pdf文件或者是word文件，通常一个条款有四十多页，如果人工复制粘贴，可想而知时间成本巨大。</span><span style="">并且更</span><span style="">糟糕</span><span style="">的是里面还有大量的表格，如下：</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image1.png" style="width: 100%"/><span style=""></span></p><p><span style="font-family:宋体;font-size:0.3rem;">目标：</span></p><p><span style="">将word转成特定样式的html文件。</span></p><p></p><p></p><p><span style="font-family:宋体;font-size:0.3rem;">方案</span><span style="font-family:宋体;font-size:0.3rem;">对比：</span></p><p><span style="">在线转换工具</span><span style=""> </span><span style=""> </span><span style="">：基本满足要求，但是在word较为复杂的时候，比如word中有列表，会表现不正常，需要手动调整，不支持字体字号与</span><span style="">颜色的转换。</span></p><p><span style="">M</span><span style="">ammoth包</span><span style="">：基本满足要求，不支持字体字号与颜色的转换，未发现其他问题。</span></p><p><span style="">word-to-html</span><span style="">：支持表格嵌套，表格合并。</span></p><p></p><p></p><p><span style="font-family:Times New Roman;font-size:0.48rem;">word-to-h</span><span style="font-family:Times New Roman;font-size:0.48rem;">tml</span></p><p><span style="font-family:宋体;font-size:0.3rem;">使用方法</span><span style="">：</span></p><p><span style="">step 1: </span><span style="">在node环境中执行下面代码，构建一个html文件用于生成最终结果</span></p><p><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">var path = require(</span><span style="color:#DD1144;font-family:Consolas;font-size:0.2rem;">'path'</span><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">);</span></p><p><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">var word2html = require(</span><span style="color:#DD1144;font-family:Consolas;font-size:0.2rem;">word-to-html'</span><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">);</span></p><p><span style="color:#999988;font-family:Consolas;font-size:0.2rem;">//Word document's absolute path</span></p><p><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">var </span><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">absPath</span><span style="color:#333333;font-family:Consolas;font-size:0.2rem;"> = </span><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">path.join</span><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">(__dirname,</span><span style="color:#DD1144;font-family:Consolas;font-size:0.2rem;">'test.docx'</span><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">);</span></p><p><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">word2html(</span><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">absPath</span><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">,{</span><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">tdVerticalAlign</span><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">:</span><span style="color:#DD1144;font-family:Consolas;font-size:0.2rem;">'top'</span><span style="color:#333333;font-family:Consolas;font-size:0.2rem;">})</span></p><p><span style="">step 2: </span><span style="">打开上述构建的html代码，在浏览器的console面板中得到最终的字符串。</span></p><p><span style="">将.</span><span style="">docx</span><span style="">文件通过node插件转换成xml字符串，然后利用</span><span style="">jsdom</span><span style="">在node环境下将xml字符串解析成为xml节点树，或者利用在browser环境下的</span><span style="">DOMpaser</span><span style="">将xml字符串解析成xml节点树，最后深度遍历xml节点树构建html文档。在browser环境下支持字体字号与颜色的转换。</span></p><p></p><p></p><p><span style="">1、利用插件</span><span style="">adm</span><span style="">-zip将docx文件转换成xml字符串</span><span style="">contentXml</span><span style="">，然后利用包含script脚本的模板构建html并写入对应的html文件中。这里convert方法是核心。</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image3.png" style="width: 100%"/></p><p><span style="">2、convert方法的代码如下，主要分两步，解析xml字符串生成xml节点树</span><span style="">，处理xml节点树生成html字符串。</span></p><p><span style="">第一步：利用</span><span style="">loadXML</span><span style="">函数解析xml字符串生成xml节点树，</span><span style="">loadXML</span><span style="">做了兼容性处理，</span><span style="">对于IE浏览器，利用</span><span style="">ActiveXObject</span><span style="">对象解析XML字符串。对于</span><span style="">chrome浏览器（</span><span style="">webkit</span><span style="">）利用</span><span style="">DOMpaser</span><span style="">进行解析。</span></p><p></p><p></p><p></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image4.png" style="width: 100%"/></p><p><span style="">解析的结果如下：</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image5.png" style="width: 100%"/><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image6.png" style="width: 100%"/></p><p><span style="">这里docx文件中从上到下分为三块：表格，文字，文字；节点树中分别对应<</span><span style="">w:tbl</span><span style="">></span><span style="">，<</span><span style="">w:</span><span style="">p</span><span style="">></span><span style="">，<</span><span style="">w:</span><span style="">p</span><span style="">></span><span style="">。再仔细观察可以找到规律，分为这三个标签的依据是回车换行符。</span></p><p></p><p></p><p><span style="">第二步：利用convert函数处理xml节点树生成html字符串</span></p><p><span style="">这里convert的逻辑很简单</span><span style="">，获取上一步解析好的xml根节点的body节点，当然这里少了对null的处理，弱类型语言的缺点，下一步用</span><span style="">ts</span><span style="">进行类型检测。然后传入</span><span style="">wanderDom</span><span style="">函数，</span><span style="">wanderDom</span><span style="">的结果即最终的html字符串。</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image7.png" style="width: 100%"/></p><p><span style="">下面看</span><span style="">对</span><span style="">wanderDom</span><span style="">函数对</span><span style="">整个文档</span><span style="">的body</span><span style="">节点进行处理：</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image8.png" style="width: 100%"/></p><p><span style="">这里会对body节点进行深度遍历，首先循环遍历body节点的子节点，对于子节点的</span><span style="">tagName</span><span style="">为</span><span style="">w</span><span style="">:</span><span style="">tbl</span><span style="">的，生成一个</span><span style="">Tbl</span><span style="">实例，并调用实例上的</span><span style="">tblFn</span><span style="">开始处理表格节点</span><span style="">，并将返回拼接到</span><span style="">htmlStr</span><span style="">。</span><span style="">对于子节点的</span><span style="">tagName</span><span style="">为</span><span style="">w</span><span style="">:</span><span style="">p</span><span style="">的，生成一个P实例，并调用实例上的</span><span style="">pFn</span><span style="">开始处理文字节点，并将返回拼接到</span><span style="">htmlStr</span><span style="">。最终返回拼接好的</span><span style="">htmlStr</span><span style="">。接下来分析两种对象的处理逻辑。</span></p><p></p><p><span style="">P实例：</span><span style="">对纯文本的处理</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image9.png" style="width: 100%"/></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image10.png" style="width: 100%"/><span style="">上面的文本可以分为三部分，分别为黑色文字，红色文字，黑色文字。这三部分内容对应着三个标签<</span><span style="">w</span><span style="">:r</span><span style="">></span><span style="">。每个<</span><span style="">w</span><span style="">:r</span><span style="">></span><span style="">标签中的<</span><span style="">w:rPr</span><span style="">></span><span style="">包含了文字的信息，比如字体字号<</span><span style="">w:rFonts</span><span style="">></span><span style="">，颜色<</span><span style="">w:color</span><span style="">></span><span style="">。每个<</span><span style="">w</span><span style="">:r</span><span style="">></span><span style="">标签中的<</span><span style="">w</span><span style="">:t</span><span style="">></span><span style="">的内容</span><span style="">t</span><span style="">extContent</span><span style="">为文本内容。因此</span><span style="">处理文字内容的逻辑</span><span style="">如下：</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image11.png" style="width: 100%"/></p><p><span style="">这里构建一个P类用于处理纯文本相关的内容。其实例方法</span><span style="">pFn</span><span style="">逻辑很简单，利用</span><span style="">getDirectDomsByTagName</span><span style="">函数获取<</span><span style="">w:p</span><span style="">></span><span style="">标签下所有的<</span><span style="">w:r</span><span style="">></span><span style="">标签对应节点组成的数组，然后将这个数组传入</span><span style="">rFn</span><span style="">，将</span><span style="">rFn</span><span style="">返回的结果用h</span><span style="">tml</span><span style="">的<</span><span style="">p></span><span style="">标签包裹起来并返回。这里的</span><span style="">getDirectDomsByTagName</span><span style="">只会获取根节点</span><span style="">dom</span><span style="">下第一层节点，保证递归正常进行下去。</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image12.png" style="width: 100%"/></p><p><span style="">接下来，来到处理文字内容的逻辑函数</span><span style="">rFn</span><span style="">，这段逻辑主要是取出传入的<</span><span style="">w:r</span><span style="">></span><span style="">数组中每个部分的文字的字体字号颜色的值，然后用<</span><span style="">span></span><span style="">标签包裹，最后返回html字符串。</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image13.png" style="width: 100%"/></p><p><span style="">这样递归的将文字进行了处理。</span></p><p></p><p><span style="">Tbl</span><span style="">实例：对表格的处理</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image14.png" style="width: 100%"/></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image15.png" style="width: 100%"/></p><p><span style="">D</span><span style="">ocx文件中表格中的行对应的标签是</span><span style="">w</span><span style="">:tr</span><span style="">，每一行中的列对应的标签是</span><span style="">w</span><span style="">:tc</span><span style="">，这里表格有一个合并单元格的效果，因此可以发现每个</span><span style="">w:tr</span><span style="">中的</span><span style="">w:tc</span><span style="">的数量不相同。在html中控制表格单元格合并的操作是在<</span><span style="">td </span><span style="">colspan</span><span style="">=${num} </span><span style="">rowspan</span><span style="">=${num}></span><span style="">，这两个属性分别控制着列方向的合并以及行方向的合并。上图中的</span><span style="">w:tc</span><span style="">中都有一个</span><span style="">w:tcPr</span><span style="">标签，包含描述这一列应该如何合并的信息。</span><span style="">w:tcPr</span><span style="">标签的子标签中描述列如何合并的标签为</span><span style="">w</span><span style="">:gridSpan</span><span style="">,</span><span style="">其属性</span><span style="">w</span><span style="">:va</span><span style="">l</span><span style="">的值表示的是</span><span style="">colspan</span><span style="">的值。</span><span style="">描述行如何合并的标签为</span><span style="">w</span><span style="">:vMerge</span><span style="">,</span><span style="">该标签上的</span><span style="">w:val</span><span style="">如果为restart则表示从本行开始该单元格合并下一行相同位置存在</span><span style="">w</span><span style="">:vMerge</span><span style="">的单元格。</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image16.png" style="width: 100%"/></p><p><span style="">表格中存在文本，因此这里遇到</span><span style="">w</span><span style="">:p</span><span style="">只需要调用上面对纯文本的逻辑。表格中也存在表格，因此遇到</span><span style="">w</span><span style="">:tbl</span><span style="">，则调用这里将要分析的对表格的处理逻辑。</span></p><p><span style="">首先看</span><span style="">Tbl</span><span style="">类的主体实现：</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image17.png" style="width: 100%"/></p><p><span style="">T</span><span style="">bl</span><span style="">类有几个实例方法与一个用于存储表格节点的</span><span style="">tblDom</span><span style="">实例属性，一个用于存储</span><span style=""><</span><span style="">w:tr</span><span style="">></span><span style="">节点组成的数组的</span><span style="">trArray</span><span style="">实例属性</span><span style="">（实例方法都能访问到的公有属性），创建</span><span style="">Tbl</span><span style="">实例的同时，需要调用实例方法</span><span style="">tblFn</span><span style="">，</span><span style="">该方法会遍历</span><span style="">w:tbl</span><span style="">下的子标签</span><span style="">w</span><span style="">:tr</span><span style="">对应的节点，将节点被传入</span><span style="">trFn</span><span style="">进行处理，</span><span style="">tblFn</span><span style="">返回</span><span style="">w:tbl</span><span style="">标签对应的html字符串</span><span style="">。</span></p><p><span style=""></span></p><p><span style="">trFn</span><span style="">会遍历其子节点</span><span style="">w:tc</span><span style="">并调用</span><span style="">tcFn</span><span style="">处理每个</span><span style="">w</span><span style="">:tc</span><span style="">对应的节点，</span><span style="">trFn</span><span style="">返回的是表格值每一行的对应的html字符串，tr字符串内容在这里组装完成。接着，</span><span style="">tcFn</span><span style="">函数非常关键，包含处理嵌套表格，合并单元格的逻辑。</span></p><p><span style="">主要有以下的步骤</span><span style="">：</span></p><p><span style="">调用</span><span style="">getTcDomOptions</span><span style="">函数获取该单元格的</span><span style="">w</span><span style="">:tcPr</span><span style="">的值</span><span style="">并计算出该单元格需要合并多少行多少列</span></p><p><span style="">然后调用</span><span style="">wanderDom</span><span style="">对该单元格的内容进行处理。</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image19.png" style="width: 100%"/></p><p><span style="">w</span><span style="">:tc</span><span style="">表示的单元格有下面几种情况：</span></p><p><span style="">合并其他单元格（包括横向和纵向）：</span></p><p><span style="">单元格内容为纯文本，</span><span style=""> </span></p><p><span style="">单元格内容为表格，</span></p><p><span style="">单元格内容有表格也有文本</span></p><p><span style="">单元格没有内容 </span><span style="">    </span></p><p><span style="">2、被合并 </span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image20.png" style="width: 100%"/></p><p><span style="">最终的结果：</span></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image21.png" style="width: 100%"/></p><p><br /><img src="/Users/liaohuanyu/项目/效率工具/word-to-html/word-to-html/test/temp/image22.png" style="width: 100%"/></p></div></html>